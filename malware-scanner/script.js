// UI Elements
const fileInput = document.getElementById('file-input');
const yaraRulesInput = document.getElementById('yara-rules');
const startScanBtn = document.getElementById('start-scan');
const stopScanBtn = document.getElementById('stop-scan');
const progressIndicator = document.getElementById('progress-indicator');
const statusText = document.getElementById('status-text');
const scanResults = document.getElementById('scan-results');
const exportJsonBtn = document.getElementById('export-json');
const loadRulesBtn = document.getElementById('load-rules');
const saveRulesBtn = document.getElementById('save-rules');
const recursiveScanCheckbox = document.getElementById('recursive-scan');
const quickScanCheckbox = document.getElementById('quick-scan');
const filesScanedCount = document.getElementById('files-scanned');
const threatsFoundCount = document.getElementById('threats-found');
const selectedFilesText = document.getElementById('selected-files');

// State
let isScanning = false;
let scanData = [];
let defaultRules = `
rule suspicious_strings {
    strings:
        $cmd_shell = "cmd.exe" nocase
        $powershell = "powershell" nocase
        $download = "wget" nocase
        $exec = "execute" nocase
        $remote = "http://" nocase
        $remote_s = "https://" nocase
        $registry = "HKEY_" nocase
        $autorun = "\\\\Software\\\\Microsoft\\\\Windows\\\\CurrentVersion\\\\Run" nocase
        $sys_dir = "\\\\system32\\\\" nocase
        $temp_dir = "\\\\temp\\\\" nocase
    condition:
        any of them
}

rule potential_malware {
    strings:
        $encrypt = "encrypt" nocase
        $ransom = "ransom" nocase
        $bitcoin = "bitcoin" nocase
        $hidden = "hidden" nocase
        $keylog = "keylog" nocase
        $steal = "steal" nocase
        $inject = "inject" nocase
        $exploit = "exploit" nocase
    condition:
        2 of them
}

rule suspicious_apis {
    strings:
        $process = "CreateProcess" nocase
        $remote_thread = "CreateRemoteThread" nocase
        $dll_inject = "LoadLibrary" nocase
        $memory_op = "VirtualAlloc" nocase
        $debug_proc = "DebugActiveProcess" nocase
        $create_service = "CreateService" nocase
        $reg_modify = "RegCreateKey" nocase
        $network = "WSAStartup" nocase
    condition:
        3 of them
}`;

// Initialize
document.addEventListener('DOMContentLoaded', () => {
    // Set default YARA rules
    yaraRulesInput.value = defaultRules;
    
    // Add event listeners
    startScanBtn.addEventListener('click', startScan);
    stopScanBtn.addEventListener('click', stopScan);
    loadRulesBtn.addEventListener('click', loadRules);
    saveRulesBtn.addEventListener('click', saveRules);
    exportJsonBtn.addEventListener('click', exportResults);
    fileInput.addEventListener('change', handleFileSelection);
    
    // Initial UI state
    updateUI(false);
});

function handleFileSelection() {
    const files = fileInput.files;
    if (files.length > 0) {
        selectedFilesText.textContent = `Selected ${files.length} file(s)`;
        startScanBtn.disabled = false;
    } else {
        selectedFilesText.textContent = 'No files selected';
        startScanBtn.disabled = true;
    }
}

function loadRules() {
    const input = document.createElement('input');
    input.type = 'file';
    input.accept = '.yar,.yara';
    
    input.onchange = async (e) => {
        try {
            const file = e.target.files[0];
            const text = await file.text();
            yaraRulesInput.value = text;
            updateStatus('YARA rules loaded successfully');
        } catch (error) {
            updateStatus('Failed to load rules: ' + error.message);
        }
    };
    
    input.click();
}

function saveRules() {
    const rules = yaraRulesInput.value;
    if (!rules.trim()) {
        updateStatus('No rules to save');
        return;
    }
    
    const blob = new Blob([rules], { type: 'text/plain' });
    const url = URL.createObjectURL(blob);
    const a = document.createElement('a');
    a.href = url;
    a.download = `yara_rules_${Date.now()}.yar`;
    document.body.appendChild(a);
    a.click();
    document.body.removeChild(a);
    URL.revokeObjectURL(url);
    updateStatus('YARA rules saved successfully');
}

async function startScan() {
    const files = fileInput.files;
    const rules = yaraRulesInput.value.trim();
    
    if (!files.length) {
        updateStatus('Please select files to scan');
        return;
    }
    
    if (!rules) {
        updateStatus('Please enter YARA rules');
        return;
    }
    
    try {
        isScanning = true;
        updateUI(true);
        scanData = [];
        clearResults();
        
        let filesScanned = 0;
        let threatsFound = 0;
        
        updateStatus('Starting malware scan...');
        
        for (let i = 0; i < files.length && isScanning; i++) {
            const file = files[i];
            const progress = ((i + 1) / files.length) * 100;
            progressIndicator.style.width = `${progress}%`;
            
            updateStatus(`Scanning ${file.name} (${formatFileSize(file.size)})`);
            
            try {
                const result = await scanFile(file, rules);
                filesScanned++;
                if (result.matches.length > 0) {
                    threatsFound += result.matches.length;
                }
                scanData.push(result);
                displayResult(result);
            } catch (error) {
                updateStatus(`Error scanning ${file.name}: ${error.message}`);
            }
            
            filesScanedCount.textContent = filesScanned;
            threatsFoundCount.textContent = threatsFound;
        }
        
        if (isScanning) {
            updateStatus('Scan completed successfully');
            exportJsonBtn.disabled = false;
        } else {
            updateStatus('Scan stopped by user');
        }
    } catch (error) {
        updateStatus(`Scan failed: ${error.message}`);
    } finally {
        isScanning = false;
        updateUI(false);
    }
}

function stopScan() {
    isScanning = false;
    updateUI(false);
    updateStatus('Scan stopped by user');
}

async function scanFile(file, rules) {
    return new Promise(async (resolve) => {
        const reader = new FileReader();
        
        reader.onload = async () => {
            const content = new Uint8Array(reader.result);
            const matches = await scanContent(content, rules);
            
            resolve({
                filename: file.name,
                size: file.size,
                timestamp: new Date().toISOString(),
                matches: matches
            });
        };
        
        reader.onerror = () => {
            resolve({
                filename: file.name,
                size: file.size,
                timestamp: new Date().toISOString(),
                error: 'Failed to read file'
            });
        };
        
        reader.readAsArrayBuffer(file);
    });
}

async function scanContent(content, rules) {
    const matches = [];
    const ruleSet = parseYaraRules(rules);
    
    for (const rule of ruleSet) {
        const ruleMatches = await checkRule(content, rule);
        if (ruleMatches.length > 0) {
            matches.push({
                rule: rule.name,
                matches: ruleMatches
            });
        }
    }
    
    return matches;
}

function parseYaraRules(rulesText) {
    const rules = [];
    const ruleRegex = /rule\s+(\w+)\s*{([^}]+)}/g;
    const stringsRegex = /\$(\w+)\s*=\s*"([^"]+)"\s*(\w+)?/g;
    const conditionRegex = /condition:\s*(.+?)(?=\n|$)/;
    
    let match;
    while ((match = ruleRegex.exec(rulesText)) !== null) {
        const ruleName = match[1];
        const ruleBody = match[2];
        
        const strings = [];
        let stringMatch;
        while ((stringMatch = stringsRegex.exec(ruleBody)) !== null) {
            strings.push({
                name: stringMatch[1],
                pattern: stringMatch[2],
                modifier: stringMatch[3] || ''
            });
        }
        
        const conditionMatch = conditionRegex.exec(ruleBody);
        if (conditionMatch) {
            rules.push({
                name: ruleName,
                strings: strings,
                condition: conditionMatch[1].trim()
            });
        }
    }
    
    return rules;
}

async function checkRule(content, rule) {
    const matches = [];
    const contentStr = new TextDecoder().decode(content);
    
    for (const string of rule.strings) {
        const regex = new RegExp(string.pattern, string.modifier === 'nocase' ? 'gi' : 'g');
        let match;
        while ((match = regex.exec(contentStr)) !== null) {
            matches.push({
                string: string.name,
                offset: match.index,
                match: match[0]
            });
        }
    }
    
    // Basic condition evaluation
    if (rule.condition.includes('any of them') && matches.length > 0) {
        return matches;
    }
    
    const numRequired = parseInt(rule.condition);
    if (!isNaN(numRequired) && matches.length >= numRequired) {
        return matches;
    }
    
    return [];
}

function displayResult(result) {
    const resultDiv = document.createElement('div');
    resultDiv.className = 'result-item';
    
    const threatLevel = result.matches.length > 2 ? 'high' : result.matches.length > 0 ? 'medium' : 'low';
    
    resultDiv.innerHTML = `
        <span class="col-file">${escapeHtml(result.filename)}</span>
        <span class="col-rule">${result.matches.map(m => escapeHtml(m.rule)).join(', ') || 'No matches'}</span>
        <span class="col-threat threat-${threatLevel}">${
            threatLevel === 'high' ? 'High' :
            threatLevel === 'medium' ? 'Medium' : 'Clean'
        }</span>
    `;
    
    scanResults.appendChild(resultDiv);
}

function exportResults() {
    if (scanData.length === 0) {
        updateStatus('No results to export');
        return;
    }

    const exportData = {
        timestamp: new Date().toISOString(),
        total_files: scanData.length,
        results: scanData
    };

    const blob = new Blob([JSON.stringify(exportData, null, 2)], { type: 'application/json' });
    const url = URL.createObjectURL(blob);
    const a = document.createElement('a');
    a.href = url;
    a.download = `scan_results_${Date.now()}.json`;
    document.body.appendChild(a);
    a.click();
    document.body.removeChild(a);
    URL.revokeObjectURL(url);
    updateStatus('Results exported successfully');
}

function updateUI(isProcessing) {
    // Update button states
    startScanBtn.disabled = isProcessing;
    stopScanBtn.disabled = !isProcessing;
    fileInput.disabled = isProcessing;
    yaraRulesInput.disabled = isProcessing;
    loadRulesBtn.disabled = isProcessing;
    saveRulesBtn.disabled = isProcessing;
    exportJsonBtn.disabled = isProcessing || scanData.length === 0;
    recursiveScanCheckbox.disabled = isProcessing;
    quickScanCheckbox.disabled = isProcessing;
    
    // Toggle progress bar animation
    if (isProcessing) {
        progressIndicator.classList.add('scanning');
        // Ensure the progress starts from 0
        progressIndicator.style.width = '0%';
    } else {
        progressIndicator.classList.remove('scanning');
        progressIndicator.style.width = '0%';
    }
}

function clearResults() {
    scanResults.innerHTML = '';
    filesScanedCount.textContent = '0';
    threatsFoundCount.textContent = '0';
    scanData = [];
    exportJsonBtn.disabled = true;
}

function updateStatus(message) {
    statusText.textContent = message;
}

function formatFileSize(bytes) {
    const units = ['B', 'KB', 'MB', 'GB'];
    let size = bytes;
    let unitIndex = 0;
    
    while (size >= 1024 && unitIndex < units.length - 1) {
        size /= 1024;
        unitIndex++;
    }
    
    return `${size.toFixed(2)} ${units[unitIndex]}`;
}

function escapeHtml(unsafe) {
    return unsafe
        .toString()
        .replace(/&/g, "&amp;")
        .replace(/</g, "&lt;")
        .replace(/>/g, "&gt;")
        .replace(/"/g, "&quot;")
        .replace(/'/g, "&#039;");
} 